<!DOCTYPE html>
<html lang="en">
<head>

    <script type='text/javascript' src='//pl27689741.revenuecpmgate.com/7b/56/d5/7b56d55d3a270b1a59076e5ed4f91d0e.js'></script>

    
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Water Sort Puzzle</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        body {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            color: white;
        }

        .container {
            width: 100%;
            max-width: 900px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 2.5rem;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .game-info {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            background: rgba(0, 0, 0, 0.2);
            padding: 15px;
            border-radius: 15px;
        }

        .level-info, .moves-info, .timer {
            font-size: 1.2rem;
            font-weight: bold;
        }

        .game-board {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 15px;
            margin-bottom: 20px;
        }

        .tube {
            width: 60px;
            height: 180px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 0 0 30px 30px;
            position: relative;
            cursor: pointer;
            margin: 0 auto;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            overflow: hidden;
            transition: transform 0.2s;
        }

        .tube.selected {
            transform: translateY(-10px);
            box-shadow: 0 15px 25px rgba(0, 0, 0, 0.3);
        }

        .tube::before {
            content: '';
            position: absolute;
            top: -5px;
            left: 0;
            right: 0;
            height: 20px;
            background: linear-gradient(to bottom, rgba(255, 255, 255, 0.8), rgba(255, 255, 255, 0.4));
            border-radius: 50%;
            z-index: 2;
        }

        .liquid {
            position: absolute;
            bottom: 0;
            width: 100%;
            border-radius: 0 0 30px 30px;
            transition: height 0.5s ease;
        }

        .controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin-bottom: 20px;
        }

        .btn {
            padding: 12px 25px;
            border: none;
            border-radius: 50px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
            transition: all 0.3s;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background: linear-gradient(to right, #ff6b6b, #ff8e8e);
            color: white;
        }

        .btn-secondary {
            background: linear-gradient(to right, #4ecdc4, #00b894);
            color: white;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
        }

        .btn:active {
            transform: translateY(0);
        }

        .level-selection {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 10px;
            margin-top: 20px;
        }

        .level-btn {
            padding: 10px;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s;
        }

        .level-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .level-btn.current {
            background: rgba(255, 255, 255, 0.4);
            border-color: white;
            transform: scale(1.1);
        }

        .completed {
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); }
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 100;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
        }

        .modal.active {
            opacity: 1;
            pointer-events: auto;
        }

        .modal-content {
            background: linear-gradient(135deg, #6a11cb 0%, #2575fc 100%);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            max-width: 400px;
            width: 90%;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
        }

        .modal h2 {
            margin-bottom: 20px;
            font-size: 2rem;
        }

        .modal p {
            margin-bottom: 25px;
            font-size: 1.2rem;
        }

        /* Responsive adjustments */
        @media (max-width: 768px) {
            .game-board {
                grid-template-columns: repeat(3, 1fr);
            }
            
            .level-selection {
                grid-template-columns: repeat(4, 1fr);
            }
        }

        @media (max-width: 480px) {
            .game-board {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .level-selection {
                grid-template-columns: repeat(3, 1fr);
            }
            
            h1 {
                font-size: 2rem;
            }
            
            .btn {
                padding: 10px 20px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>Water Sort Puzzle</h1>
            <p>Sort the colored water until each tube contains only one color</p>
        </header>
        
        <div class="game-info">
            <div class="level-info">Level: <span id="level-number">1</span>/20</div>
            <div class="moves-info">Moves: <span id="moves-count">0</span></div>
            <div class="timer">Time: <span id="time">00:00</span></div>
        </div>
        
        <div class="game-board" id="game-board">
            <!-- Tubes will be generated here -->
        </div>
        
        <div class="controls">
            <button class="btn btn-primary" id="reset-btn">
                <i class="fas fa-redo"></i> Reset Level
            </button>
            <button class="btn btn-secondary" id="pause-btn">
                <i class="fas fa-pause"></i> Pause
            </button>
            <button class="btn btn-primary" id="prev-level-btn">
                <i class="fas fa-arrow-left"></i> Previous
            </button>
            <button class="btn btn-primary" id="next-level-btn">
                Next <i class="fas fa-arrow-right"></i>
            </button>
        </div>
        
        <h3>Select Level:</h3>
        <div class="level-selection" id="level-buttons">
            <!-- Level buttons will be generated here -->
        </div>
    </div>
    
    <div class="modal" id="pause-modal">
        <div class="modal-content">
            <h2>Game Paused</h2>
            <p>Take your time! Ready to continue?</p>
            <button class="btn btn-secondary" id="resume-btn">
                <i class="fas fa-play"></i> Resume Game
            </button>
        </div>
    </div>
    
    <div class="modal" id="level-complete-modal">
        <div class="modal-content">
            <h2>Level Complete!</h2>
            <p>You finished in <span id="complete-time">00:00</span> with <span id="complete-moves">0</span> moves</p>
            <button class="btn btn-secondary" id="next-level-modal-btn">
                Next Level <i class="fas fa-arrow-right"></i>
            </button>
        </div>
    </div>

    <script>
        // Game state
        const gameState = {
            currentLevel: 1,
            moves: 0,
            time: 0,
            timerInterval: null,
            isPaused: false,
            selectedTube: null,
            tubes: [],
            levelConfig: {}
        };

        // Level configurations (simplified for demo)
        const levelConfigs = {
            1: { tubes: 5, colors: 3, emptyTubes: 2 },
            2: { tubes: 5, colors: 4, emptyTubes: 1 },
            3: { tubes: 6, colors: 4, emptyTubes: 2 },
            4: { tubes: 6, colors: 5, emptyTubes: 1 },
            5: { tubes: 7, colors: 5, emptyTubes: 2 },
            6: { tubes: 7, colors: 6, emptyTubes: 1 },
            7: { tubes: 8, colors: 6, emptyTubes: 2 },
            8: { tubes: 8, colors: 7, emptyTubes: 1 },
            9: { tubes: 9, colors: 7, emptyTubes: 2 },
            10: { tubes: 9, colors: 8, emptyTubes: 1 },
            11: { tubes: 10, colors: 8, emptyTubes: 2 },
            12: { tubes: 10, colors: 9, emptyTubes: 1 },
            13: { tubes: 11, colors: 9, emptyTubes: 2 },
            14: { tubes: 11, colors: 10, emptyTubes: 1 },
            15: { tubes: 12, colors: 10, emptyTubes: 2 },
            16: { tubes: 12, colors: 11, emptyTubes: 1 },
            17: { tubes: 13, colors: 11, emptyTubes: 2 },
            18: { tubes: 13, colors: 12, emptyTubes: 1 },
            19: { tubes: 14, colors: 12, emptyTubes: 2 },
            20: { tubes: 14, colors: 13, emptyTubes: 1 }
        };

        // Color palette
        const colors = [
            '#FF5252', // red
            '#FF4081', // pink
            '#E040FB', // purple
            '#7C4DFF', // deep purple
            '#536DFE', // indigo
            '#448AFF', // blue
            '#40C4FF', // light blue
            '#18FFFF', // cyan
            '#64FFDA', // teal
            '#69F0AE', // green
            '#B2FF59', // light green
            '#EEFF41', // lime
            '#FFFF00', // yellow
            '#FFD740', // amber
            '#FFAB40', // orange
            '#FF6E40'  // deep orange
        ];

        // Initialize the game
        function initGame() {
            generateLevelButtons();
            loadLevel(1);
            startTimer();
            
            // Event listeners
            document.getElementById('reset-btn').addEventListener('click', resetLevel);
            document.getElementById('pause-btn').addEventListener('click', pauseGame);
            document.getElementById('resume-btn').addEventListener('click', resumeGame);
            document.getElementById('prev-level-btn').addEventListener('click', previousLevel);
            document.getElementById('next-level-btn').addEventListener('click', nextLevel);
            document.getElementById('next-level-modal-btn').addEventListener('click', nextLevel);
        }

        // Generate level selection buttons
        function generateLevelButtons() {
            const container = document.getElementById('level-buttons');
            container.innerHTML = '';
            
            for (let i = 1; i <= 20; i++) {
                const button = document.createElement('button');
                button.className = 'level-btn';
                button.textContent = i;
                if (i === 1) button.classList.add('current');
                
                button.addEventListener('click', () => loadLevel(i));
                container.appendChild(button);
            }
        }

        // Load a specific level
        function loadLevel(level) {
            gameState.currentLevel = level;
            gameState.moves = 0;
            gameState.selectedTube = null;
            gameState.levelConfig = levelConfigs[level];
            
            updateUI();
            generateTubes();
            
            // Update level buttons
            document.querySelectorAll('.level-btn').forEach((btn, index) => {
                if (index + 1 === level) {
                    btn.classList.add('current');
                } else {
                    btn.classList.remove('current');
                }
            });
            
            // Reset timer if it was running
            if (gameState.timerInterval) {
                clearInterval(gameState.timerInterval);
            }
            gameState.time = 0;
            startTimer();
            
            // Close any open modals
            document.getElementById('pause-modal').classList.remove('active');
            document.getElementById('level-complete-modal').classList.remove('active');
        }

        // Generate tubes based on current level
        function generateTubes() {
            const board = document.getElementById('game-board');
            board.innerHTML = '';
            gameState.tubes = [];
            
            const { tubes: tubeCount, colors: colorCount, emptyTubes } = gameState.levelConfig;
            
            // Create color distribution for the level
            const colorSet = colors.slice(0, colorCount);
            const liquidColors = [];
            
            // Each color appears 4 times (to fill tubes)
            for (let i = 0; i < colorCount; i++) {
                for (let j = 0; j < 4; j++) {
                    liquidColors.push(colorSet[i]);
                }
            }
            
            // Shuffle the colors
            shuffleArray(liquidColors);
            
            // Create tubes
            for (let i = 0; i < tubeCount; i++) {
                const tube = document.createElement('div');
                tube.className = 'tube';
                tube.dataset.index = i;
                
                // Add liquids to tube (first few tubes get colors, others remain empty)
                const tubeDiv = document.createElement('div');
                if (i < tubeCount - emptyTubes) {
                    const tubeColors = liquidColors.slice(i * 4, (i + 1) * 4);
                    gameState.tubes.push([...tubeColors]);
                    
                    for (let j = 0; j < 4; j++) {
                        if (tubeColors[j]) {
                            const liquid = document.createElement('div');
                            liquid.className = 'liquid';
                            liquid.style.backgroundColor = tubeColors[j];
                            liquid.style.height = `${25 * (j + 1)}%`;
                            liquid.style.zIndex = 4 - j;
                            tube.appendChild(liquid);
                        }
                    }
                } else {
                    gameState.tubes.push([]);
                }
                
                tube.addEventListener('click', () => handleTubeClick(i));
                board.appendChild(tube);
            }
        }

        // Handle tube selection and liquid transfer
        function handleTubeClick(tubeIndex) {
            if (gameState.isPaused) return;
            
            // If no tube is selected, select this one
            if (gameState.selectedTube === null) {
                gameState.selectedTube = tubeIndex;
                document.querySelectorAll('.tube')[tubeIndex].classList.add('selected');
                return;
            }
            
            // If the same tube is clicked again, deselect it
            if (gameState.selectedTube === tubeIndex) {
                document.querySelectorAll('.tube')[tubeIndex].classList.remove('selected');
                gameState.selectedTube = null;
                return;
            }
            
            // Try to pour from selected tube to clicked tube
            const fromTube = gameState.tubes[gameState.selectedTube];
            const toTube = gameState.tubes[tubeIndex];
            
            // Check if move is valid
            if (isValidPour(fromTube, toTube)) {
                // Perform the pour
                const colorToPour = fromTube[fromTube.length - 1];
                let pourAmount = 0;
                
                // Calculate how much of the same color we can pour
                for (let i = fromTube.length - 1; i >= 0; i--) {
                    if (fromTube[i] === colorToPour) {
                        pourAmount++;
                    } else {
                        break;
                    }
                }
                
                // Limit pour amount by available space in destination tube
                pourAmount = Math.min(pourAmount, 4 - toTube.length);
                
                // Update game state
                for (let i = 0; i < pourAmount; i++) {
                    toTube.push(fromTube.pop());
                }
                
                // Update UI
                updateTubesUI();
                
                // Increment move count
                gameState.moves++;
                updateUI();
                
                // Check for level completion
                if (checkLevelComplete()) {
                    completeLevel();
                }
            }
            
            // Deselect the tube regardless of whether pour was successful
            document.querySelectorAll('.tube')[gameState.selectedTube].classList.remove('selected');
            gameState.selectedTube = null;
        }

        // Check if pouring from one tube to another is valid
        function isValidPour(fromTube, toTube) {
            // Can't pour from an empty tube
            if (fromTube.length === 0) return false;
            
            // Can't pour to a full tube
            if (toTube.length === 4) return false;
            
            const colorToPour = fromTube[fromTube.length - 1];
            
            // Can pour to an empty tube
            if (toTube.length === 0) return true;
            
            // Can only pour to a tube with the same top color
            return toTube[toTube.length - 1] === colorToPour;
        }

        // Update tubes UI based on game state
        function updateTubesUI() {
            const tubeElements = document.querySelectorAll('.tube');
            
            tubeElements.forEach((tubeElement, index) => {
                // Clear existing liquids
                const liquids = tubeElement.querySelectorAll('.liquid');
                liquids.forEach(liquid => liquid.remove());
                
                // Add new liquids
                const tubeData = gameState.tubes[index];
                for (let i = 0; i < tubeData.length; i++) {
                    const liquid = document.createElement('div');
                    liquid.className = 'liquid';
                    liquid.style.backgroundColor = tubeData[i];
                    liquid.style.height = `${25 * (i + 1)}%`;
                    liquid.style.zIndex = tubeData.length - i;
                    tubeElement.appendChild(liquid);
                }
            });
        }

        // Check if level is complete
        function checkLevelComplete() {
            for (const tube of gameState.tubes) {
                // If tube is not empty and not full of same color, level is not complete
                if (tube.length > 0) {
                    if (tube.length !== 4) return false;
                    
                    const color = tube[0];
                    for (let i = 1; i < 4; i++) {
                        if (tube[i] !== color) return false;
                    }
                }
            }
            
            return true;
        }

        // Handle level completion
        function completeLevel() {
            clearInterval(gameState.timerInterval);
            
            // Show completion modal
            document.getElementById('complete-time').textContent = formatTime(gameState.time);
            document.getElementById('complete-moves').textContent = gameState.moves;
            document.getElementById('level-complete-modal').classList.add('active');
            
            // Mark level as completed in level selection
            document.querySelectorAll('.level-btn')[gameState.currentLevel - 1].classList.add('completed');
        }

        // Reset current level
        function resetLevel() {
            loadLevel(gameState.currentLevel);
        }

        // Pause the game
        function pauseGame() {
            gameState.isPaused = true;
            clearInterval(gameState.timerInterval);
            document.getElementById('pause-modal').classList.add('active');
        }

        // Resume the game
        function resumeGame() {
            gameState.isPaused = false;
            startTimer();
            document.getElementById('pause-modal').classList.remove('active');
        }

        // Load next level
        function nextLevel() {
            if (gameState.currentLevel < 20) {
                loadLevel(gameState.currentLevel + 1);
            } else {
                // If on last level, go back to first level
                loadLevel(1);
            }
        }

        // Load previous level
        function previousLevel() {
            if (gameState.currentLevel > 1) {
                loadLevel(gameState.currentLevel - 1);
            } else {
                // If on first level, go to last level
                loadLevel(20);
            }
        }

        // Start the timer
        function startTimer() {
            clearInterval(gameState.timerInterval);
            gameState.timerInterval = setInterval(() => {
                if (!gameState.isPaused) {
                    gameState.time++;
                    document.getElementById('time').textContent = formatTime(gameState.time);
                }
            }, 1000);
        }

        // Format time in MM:SS format
        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = seconds % 60;
            return `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        // Update UI elements
        function updateUI() {
            document.getElementById('level-number').textContent = gameState.currentLevel;
            document.getElementById('moves-count').textContent = gameState.moves;
            document.getElementById('time').textContent = formatTime(gameState.time);
        }

        // Utility function to shuffle an array
        function shuffleArray(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        // Initialize the game when the page loads
        window.addEventListener('load', initGame);
    </script>
</body>
</html>
